package main

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/disgoorg/disgo/discord"
	"github.com/disgoorg/disgo/webhook"
	_ "github.com/lib/pq"
)

var (
	host     = "db"
	port     = 5432
	user     = "postgres"
	password = os.Getenv("POSTGRES_PASSWORD")
	dbname   = "gzctf"
)

func connect() (*sql.DB, error) {
	psqlconn := fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=disable", host, port, user, password, dbname)
	db, err := sql.Open("postgres", psqlconn)
	if err != nil {
		return nil, err
	}
	err = db.Ping()
	if err != nil {
		return nil, err
	}
	fmt.Println("Connected to the database!")
	return db, nil
}

type GameNotice struct {
	Id             int
	NoticeType     int
	Values         []string
	PublishTimeUtc time.Time
	GameId         int
}

func getLastNoticeID(db *sql.DB) (int, error) {
	var lastNoticeID int
	err := db.QueryRow("SELECT COALESCE(MAX(\"Id\"), 0) FROM \"GameNotices\"").Scan(&lastNoticeID)
	if err != nil {
		return 0, err
	}
	return lastNoticeID, nil
}

func main() {
	db, err := connect()
	for err != nil {
		fmt.Println("Error connecting to database:", err)
		time.Sleep(1 * time.Second)
		db, err = connect()
	}
	defer db.Close()

	lastNoticeID, err := getLastNoticeID(db)
	if err != nil {
		panic(err)
	}

	webhookURL := os.Getenv("GZCTF_DISCORD_WEBHOOK")
	client, err := webhook.NewWithURL(webhookURL)
	if err != nil {
		panic(err)
	}

	embed := discord.NewEmbedBuilder().
		SetTitle("Successfully Integrated To The CTFIFY GZCLI BOT ~ by TCP1P Community").
		SetDescription(fmt.Sprintf("Thank you for using our service :)")).
		SetColor(0x00ff00).
		Build()
	client.CreateEmbeds([]discord.Embed{embed})

	for {
		var newNotices []GameNotice

		rows, err := db.Query("SELECT \"Id\", \"Type\", \"Values\", \"PublishTimeUtc\", \"GameId\" FROM \"GameNotices\" WHERE \"Id\" > $1", lastNoticeID)
		if err != nil {
			fmt.Println("Error querying database:", err)
			time.Sleep(1 * time.Second)
			continue
		}

		/**
		   Column    |         Type          | Collation | Nullable |             Default
		-------------+-----------------------+-----------+----------+----------------------------------
		 Id          | integer               |           | not null | generated by default as identity
		 Name        | character varying(20) |           | not null |
		 Bio         | character varying(72) |           |          |
		 AvatarHash  | character varying(64) |           |          |
		 Locked      | boolean               |           | not null |
		 InviteToken | character varying(32) |           | not null |
		 CaptainId   | uuid                  |           | not null |
		*/

		db.Exec("UPDATE \"Teams\" SET \"Locked\" = false")

		for rows.Next() {
			var notice GameNotice
			var values string
			err := rows.Scan(&notice.Id, &notice.NoticeType, &values, &notice.PublishTimeUtc, &notice.GameId)
			if err != nil {
				fmt.Println("Error scanning row:", err)
				continue
			}
			err = json.Unmarshal([]byte(values), &notice.Values)
			if err != nil {
				fmt.Println("Error unmarshalling values:", err)
				continue
			}
			newNotices = append(newNotices, notice)
		}
		rows.Close()

		if len(newNotices) > 0 {
			lastNoticeID = newNotices[len(newNotices)-1].Id
			replacements := map[string]string{
				"@everyone": "@everyon3",
				"@here":     "@her3",
			}
			for _, notice := range newNotices {
				for i, value := range notice.Values {
					for old, new := range replacements {
						notice.Values[i] = strings.Replace(value, old, new, -1)
					}
				}
				var embed discord.Embed
				switch notice.NoticeType {
				case 1: // First Blood
					embed = discord.NewEmbedBuilder().
						SetTitle("First Blood").
						SetDescription(fmt.Sprintf(":first_place: The first one to solve **%s** was team **%s**! :drop_of_blood:", notice.Values[1], notice.Values[0])).
						SetColor(0xFF0303).
						Build()
				case 2: // Second Blood
					embed = discord.NewEmbedBuilder().
						SetTitle("Second Blood").
						SetDescription(fmt.Sprintf(":second_place: The second one to solve **%s** was team **%s**! :sunglasses:", notice.Values[1], notice.Values[0])).
						SetColor(0xFFD503).
						Build()
				case 3: // Third Blood
					embed = discord.NewEmbedBuilder().
						SetTitle("Third Blood").
						SetDescription(fmt.Sprintf(":third_place: The third one to solve **%s** was team **%s**! :sunglasses:", notice.Values[1], notice.Values[0])).
						SetColor(0x96FF03).
						Build()
				case 4: // New Hint
					embed = discord.NewEmbedBuilder().
						SetTitle("New Hint").
						SetDescription(fmt.Sprintf(":bulb: A new hint for **%s** has been published! :bulb:", notice.Values[0])).
						SetColor(0x0320FF).
						Build()
				case 5: // New Challenge
					embed = discord.NewEmbedBuilder().
						SetTitle("New Challenge").
						SetDescription(fmt.Sprintf(":tada: **%s** challenge has been published! :tada:", notice.Values[0])).
						SetColor(0x03FFC8).
						Build()
				default:
					continue
				}
				_, err := client.CreateEmbeds([]discord.Embed{embed})
				if err != nil {
					fmt.Println("Error sending webhook:", err)
				}
			}
		}

		time.Sleep(1 * time.Second)
	}
}
