package main

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"os"
	"regexp"
	"strings"
	"time"

	"github.com/disgoorg/disgo/discord"
	"github.com/disgoorg/disgo/webhook"
	_ "github.com/lib/pq"
)

var (
	host     = "db"
	port     = 5432
	user     = "postgres"
	password = os.Getenv("POSTGRES_PASSWORD")
	dbname   = "gzctf"
)

func connect() (*sql.DB, error) {
	psqlconn := fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=disable", host, port, user, password, dbname)
	db, err := sql.Open("postgres", psqlconn)
	if err != nil {
		return nil, err
	}
	err = db.Ping()
	if err != nil {
		return nil, err
	}
	fmt.Println("Connected to the database!")
	return db, nil
}

type GameNotice struct {
	Id             int
	NoticeType     int
	Values         []string
	PublishTimeUtc time.Time
	GameId         int
}

func getLastNoticeID(db *sql.DB) (int, error) {
	var lastNoticeID int
	err := db.QueryRow("SELECT COALESCE(MAX(\"Id\"), 0) FROM \"GameNotices\"").Scan(&lastNoticeID)
	if err != nil {
		return 0, err
	}
	return lastNoticeID, nil
}

func main() {
	db, err := connect()
	icon := "https://tcp1p.team/_next/static/media/TCP1P%20_Main%20White%20Red.89fd023d.svg"
	for err != nil {
		fmt.Println("Error connecting to database:", err)
		time.Sleep(1 * time.Second)
		db, err = connect()
	}
	defer db.Close()

	lastNoticeID, err := getLastNoticeID(db)
	if err != nil {
		panic(err)
	}

	webhookURL := os.Getenv("GZCTF_DISCORD_WEBHOOK")
	client, err := webhook.NewWithURL(webhookURL)
	if err != nil {
		panic(err)
	}

	// Welcome embed
	embed := discord.NewEmbedBuilder().
		SetTitle("‚úÖ Successfully Integrated").
		SetDescription("Connected to **CTFIFY GZCLI BOT** ~ by TCP1P Community.\n\nThank you for using our service üöÄ").
		SetColor(0x00ff00).
		SetTimestamp(time.Now()).
		SetFooter("CTF Updates ‚Ä¢ by TCP1P Community", "").
		Build()
	client.CreateEmbeds([]discord.Embed{embed})

	for {
		var newNotices []GameNotice

		rows, err := db.Query("SELECT \"Id\", \"Type\", \"Values\", \"PublishTimeUtc\", \"GameId\" FROM \"GameNotices\" WHERE \"Id\" > $1", lastNoticeID)
		if err != nil {
			fmt.Println("Error querying database:", err)
			time.Sleep(1 * time.Second)
			continue
		}

		db.Exec("UPDATE \"Teams\" SET \"Locked\" = false")

		for rows.Next() {
			var notice GameNotice
			var values string
			err := rows.Scan(&notice.Id, &notice.NoticeType, &values, &notice.PublishTimeUtc, &notice.GameId)
			if err != nil {
				fmt.Println("Error scanning row:", err)
				continue
			}
			err = json.Unmarshal([]byte(values), &notice.Values)
			if err != nil {
				fmt.Println("Error unmarshalling values:", err)
				continue
			}
			newNotices = append(newNotices, notice)
		}
		rows.Close()

		if len(newNotices) > 0 {
			lastNoticeID = newNotices[len(newNotices)-1].Id
			replacements := map[string]string{
				"@everyone": "@everyon3",
				"@here":     "@her3",
			}
			for _, notice := range newNotices {
				// Sanitize team name if this is a team-related notice
				if notice.NoticeType >= 1 && notice.NoticeType <= 3 && len(notice.Values) > 0 {
					// Remove invalid characters from team name
					sanitized := regexp.MustCompile(`[^a-zA-Z0-9!@#$%^&*()_+\-={}\[\]:"';<>,.?/\\]`).ReplaceAllString(notice.Values[0], "")
					if sanitized != notice.Values[0] {
						fmt.Printf("Sanitized team name from '%s' to '%s'\n", notice.Values[0], sanitized)
						notice.Values[0] = sanitized
					}
				}

				for i, value := range notice.Values {
					for old, new := range replacements {
						notice.Values[i] = strings.Replace(value, old, new, -1)
					}
				}
				var embed discord.Embed
				switch notice.NoticeType {
				case 1: // First Blood
					embed = discord.NewEmbedBuilder().
						SetTitle("üèÜ First Blood!").
						SetDescription(fmt.Sprintf("Team **%s** was the first to solve:", notice.Values[0])).
						AddField("Challenge", fmt.Sprintf("`%s`", notice.Values[1]), false).
						SetColor(0xE74C3C). // red
						SetFooter("CTF Updates ‚Ä¢ by TCP1P Community", icon).
						SetTimestamp(time.Now()).
						Build()

				case 2: // Second Blood
					embed = discord.NewEmbedBuilder().
						SetTitle("ü•à Second Blood").
						SetDescription(fmt.Sprintf("Team **%s** claimed the second solve:", notice.Values[0])).
						AddField("Challenge", fmt.Sprintf("`%s`", notice.Values[1]), false).
						SetColor(0xF1C40F). // gold
						SetFooter("CTF Updates ‚Ä¢ by TCP1P Community", icon).
						SetTimestamp(time.Now()).
						Build()

				case 3: // Third Blood
					embed = discord.NewEmbedBuilder().
						SetTitle("ü•â Third Blood").
						SetDescription(fmt.Sprintf("Team **%s** secured the third solve:", notice.Values[0])).
						AddField("Challenge", fmt.Sprintf("`%s`", notice.Values[1]), false).
						SetColor(0x2ECC71). // green
						SetFooter("CTF Updates ‚Ä¢ by TCP1P Community", icon).
						SetTimestamp(time.Now()).
						Build()

				case 4: // New Hint
					embed = discord.NewEmbedBuilder().
						SetTitle("üí° New Hint Released").
						SetDescription("A hint was just published for a challenge:").
						AddField("Challenge", fmt.Sprintf("`%s`", notice.Values[0]), false).
						SetColor(0x3498DB). // blue
						SetFooter("CTF Updates ‚Ä¢ by TCP1P Community", icon).
						SetTimestamp(time.Now()).
						Build()

				case 5: // New Challenge
					embed = discord.NewEmbedBuilder().
						SetTitle("üéâ New Challenge Available!").
						SetDescription("A new challenge has just been published:").
						AddField("Challenge", fmt.Sprintf("`%s`", notice.Values[0]), false).
						SetColor(0x9B59B6). // purple
						SetFooter("CTF Updates ‚Ä¢ by TCP1P Community", icon).
						SetTimestamp(time.Now()).
						Build()

				default:
					continue
				}

				_, err := client.CreateEmbeds([]discord.Embed{embed})
				if err != nil {
					fmt.Println("Error sending webhook:", err)
				}
			}
		}

		time.Sleep(1 * time.Second)
	}
}
